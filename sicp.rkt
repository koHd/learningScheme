#lang racket

; working through Structure and Interpretation of Computer Programs

; 1.1 The Elements of Programming

(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (two-largest x y z)
  (cond ((and (< x y) (< x z)) (cons y z))
        ((and (< y x) (< y z)) (cons x z))
        (else (cons x y))))

(define (sum-of-squares-two-largest x y z)
  (sum-of-squares (car (two-largest x y z)) (cdr (two-largest x y z))))

(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))

(define (average x y)
  (/ (+ x y) 2))

; 1.2 Procedures and the Processes They Generate
; 1.2.1 Linear Recursion and Iteration

(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

(define (factorial2 n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))

; Exercise 1.9

;(+ 4 5)
;(inc (+ (dec 4) 5))
;(inc (+ 3 5))
;(inc (inc (+ (dec 3) 5)))
;(inc (inc (+ 2 5)))
;(inc (inc (inc (+ (dec 2) 5))))
;(inc (inc (inc (+ 1 5))))
;(inc (inc (inc (inc (+ (dec 1) 5)))))
;(inc (inc (inc (inc (+ 0 5)))))
;(inc (inc (inc (inc 5))))
;(inc (inc (inc 6)))
;(inc (inc 7))
;(inc 8)
;9
; this is a linearly recursive process generated by a recursive procedure


;(+ 4 5)
;(+ (dec 4) (inc 5))
;(+ 3 6)
;(+ (dec 3) (inc 6))
;(+ 2 7)
;(+ (dec 2) (inc 7))
;(+ 1 8)
;(+ (dec 1) (inc 8))
;(+ 0 9)
;9
; this is a linearly iterative process generated by a recursive procedure

; Exercise 1.10

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

;(A 1 10)
;(A (- 1 1) (A 1 (- 10 1)))
;(A 0 (A 1 9))
;(A 0 (A (- 1 1) (A 1 (- 9 1)))
;(A 0 (A 0 (A 1 8)))
;(A 0 (A 0 (A (- 1 1) (A 1 (- 8 1)))));
;(A 0 (A 0 (A 0 (A 1 7))))
;(A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 7 1))))))
;(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
;(A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1)))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 4 1)))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 3 1))))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1)))))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4)))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 8))))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 (* 2 16)))))))
;(A 0 (A 0 (A 0 (A 0 (A 0 32))))))
;(A 0 (A 0 (A 0 (A 0 (* 2 32))))))
;(A 0 (A 0 (A 0 (A 0 64)))))
;(A 0 (A 0 (A 0 (* 2 64)))))
;(A 0 (A 0 (A 0 128))))
;(A 0 (A 0 (* 2 128))))
;(A 0 (A 0 256)))
;(A 0 (* 2 256)))
;(A 0 512))
;(* 2 512))
;1024

;(A x y) = (2^x)^(2^y)

; 1.2.2 Tree Recursion

; inefficient fibonaci tree recusrive procedure
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

;(fib 3)
;(+ (fib (- 3 1)) (fib (- 3 2)))
;(+ (fib 2) (fib 1))
;(+ (+ (fib (- 2 1)) (fib (- 2 2)) 1)
;(+ (+ (fib 1) (fib 0)) 1)
;(+ (+ 1 0) 1)
;(+ 1 1)
;2

; a more efficient fibonaci procedure (linear iteration)

(define (fib2 n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))

;(fib2 3)
;(fib-iter 1 0 3)
;(fib-iter (+ 1 0) 1 (- 3 1))
;(fib-iter 1 1 2)
;(fib-iter (+ 1 1) 1 (- 2 1))
;(fib-iter 2 1 1)
;(fib-iter (+ 2 1) 2 (- 1 1))
;(fib-iter 3 2 0)
;2

; 1.2.4 Expnentiation

; linear recursive function O(n) steps and O(n) space

(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))

;(expt 2 3)
;(* 2 (expt 2 (- 3 1)))
;(* 2 (expt 2 2))
;(* 2 (* 2 (expt 2 (- 2 1))))
;(* 2 (* 2 (expt 2 1)))
;(* 2 (* 2 (* 2 (expt 2 (- 1 1)))))
;(* 2 (* 2 (* 2 (expt 2 0))))
;(* 2 (* 2 (* 2 1)))
;(* 2 (* 2 2))
;(* 2 4)
;8

; linear iteration O(n) steps and O(1) space

(define (expt2 b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))

;(expt2 2 3)
;(expt-iter 2 3 1)
;(expt-iter 2 (- 3 1) (* 2 1))
;(expt-iter 2 2 2)
;(expt-iter 2 (- 2 1) (* 2 2))
;(expt-iter 2 1 4)
;(expt-iter 2 (- 1 1) (* 2 4))
;(expt-iter 2 0 8)
;8

; fast exponentiation O(logn)

(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(define (even? n)
  (= (remainder n 2) 0))

; 1.3 Formulating Abstractions with Higher-Order Procedures

; sum of the integers a through b:

(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))

; sum of the cubes of the integers in the given range:

(define (cube x)
  (* x x x))

(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))

; abstract idea: summation of a series

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (inc n) (+ n 1))

(define (sum-cubes2 a b)
  (sum cube a inc b))

;(sum-cubes2 1 3)
;(sum cube 1 inc 3)
;(+ (cube 1) (sum cube (inc 1) inc 3))
;(+ 1 (sum cube 2 inc 3))
;(+ 1 (+ (cube 2) (sum cube (inc 2) inc 3))))
;(+ 1 (+ 8 (sum cube 3 inc 3)))
;(+ 1 (+ 8 (+ (cube 3) (sum cube (inc 3) inc 3))))
;(+ 1 (+ 8 (+ 27 (sum cube 4 inc 3))))
;(+ 1 (+ 8 (+ 27 0)))
;(+ 1 (+ 8 27))
;(+ 1 35)
;36

(define (identity x) x)

(define (sum-integers2 a b)
  (sum identity a inc b))

;(sum-integers2 1 3)
;(sum identity 1 inc 3)
;(+ (identity 1) (sum identity (inc 1) inc 3))
;(+ 1 (sum identity 2 inc 3))
;(+ 1 (+ (identity 2) (sum identity (inc 2) inc 3)))
;(+ 1 (+ 2 (sum identity 3 inc 3)))
;(+ 1 (+ 2 (+ (identity 3) (sum identity (inc 3) inc 3))))
;(+ 1 (+ 2 (+ 3 (sum identity 4 inc 3))))
;(+ 1 (+ 2 (+ 3 0)))
;(+ 1 (+ 2 3))
;(+ 1 5)
;6

; 1.3.2 Constructing Procedures Using Lambda

; "the procedure that returns its input incremented by 4"

(lambda (x) (+ x 4))

; can be read as: the procedure of an argument x that adds x and 4

; in general: (lambda (<formal-parameters>) <body>)

; this can be handy for small auxilary procedures such as identity and inc above. It will save us having to define them seperately

(define (sum-integers3 a b)
  (sum (lambda (x) x) a (lambda (x) (+ x 1)) b))

;Using let to create local variables
;example problem:
; f(x, y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y)
; which can be simplified to:
; a = 1 + xy
; b = 1 - y
; s.t:
; f(x, y) = xa^2 + yb + ab

(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b ( - 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))

; can be thought of as saying:
; let <var1> have the value <exp1> and
;     <var2> have the value <exp2> and
;     ...
;     <varn> have the value <expn>
; in  <body>

; the let expression can be considered syntactic sugar for the lambda alternative:
; ((lambda (<var1> ... <varn>)
;       <body>)
;   <exp1>
;   ...
;   <expn>

; Exercise 1.34

(define (fun g)
  (g 2))

;(fun square)
;(sqaure 2)
;(* 2 2)
;4

;(fun (lambda (z) (* z (+ z 1))))
;((lambda (z) (* z (+ z 1))) 2)
;(* 2 (+ 2 1))
;(* 2 3)
;6

;(fun fun)
;(fun 2)
;(2 2)
; application: not a procedute;
; expected a procedure that can be applied to arguments
;   given: 2
;   arguments...;

; flatten all atoms contained in nested lists into single list
; eg:
;(flatten-all-atoms (list 1 (list 2 3) 4))
;(1 2 3 4)



(define (displayln-atoms lst)
  (let ([flattened-lst (flatten lst)])
    (cond
      [(empty? flattened-lst) null]
      [else (displayln (car flattened-lst))
            (displayln-atoms (cdr flattened-lst))])))

(define (duplicate-list n lst)
  (cond
    [(empty? lst) null]
    [else (cons (duplicate n (car lst)) (duplicate-list n (cdr lst)))]))

;(duplicate-list 2 (list 1 2 3))
;(cons (duplicate 2 (car lst)) (duplicate-list (- 2 1) (cdr lst)))
;(cons (duplicate 2 1) (duplicate-list 1 (list 2 3)))
;(cons (duplicate 2 1) (cons (duplicate 1

(define (duplicate n txt)
  (if (zero? n)
      null
      (cons txt (duplicate (- n 1) txt))))

(define (reverse-with-count counts items)
  (cond
    [(empty? items) null]
    [else (append (reverse-with-count (cdr counts) (cdr items))
                (duplicate (car counts) (car items)))]))

;(reverse-with-count '(1 2) '(a b))
;(append (reverse-with-count (cdr '(1 2)) (cdr '(a b))) (duplicate (car '1 2)) (car '(a b))))
;(append (reverse-with-count (cdr '(1 2)) (cdr '(a b))) (duplicate 1 a))
;(append (reverse-with-count (cdr '(1 2)) (cdr '(a b))) (cons a (duplicate (- 1 1) a)))
;(append (reverse-with-count (cdr '(1 2)) (cdr '(a b))) (cons a (duplicate 0 a)))
;(append (reverse-with-count (cdr '(1 2)) (cdr '(a b))) (cons a))
;(append (reverse-with-count (cdr '(1 2)) (cdr '(a b))) '(a))
;(append (reverse-with-count '(2)) '(b))) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) (duplicate (car '(2)) (car '(b))) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) (duplicate 2 b) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) (cons b (duplicate (- 2 1) b)) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) (cons b (duplicate 1 b)) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) (cons b (cons b (duplicate (- 1 1) b)) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) (cons b (cons b (duplicate 0 b)) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b ))) (cons b (cons b) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) '(b b) '(a))
;(append (append (reverse-with-count (cdr '(2)) (cdr '(b))) '(b b) '(a))
;(append (append (reverse-with-count '() '())) '(b b) '(a))
;(append (append null '(b b) '(a))
;(append '(b b) '(a))
;'(b b a)



